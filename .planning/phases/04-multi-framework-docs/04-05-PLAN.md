---
phase: 04-multi-framework-docs
plan: 05
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - .knowledge/patterns/micro-interactions/button-hover-effect.yaml
  - .knowledge/patterns/micro-interactions/ripple-effect.yaml
  - .knowledge/patterns/data-display/data-table.yaml
  - .knowledge/patterns/data-display/stat-card.yaml
  - .knowledge/patterns/authentication/login-form.yaml
autonomous: true

must_haves:
  truths:
    - "All micro-interaction patterns have animation-focused documentation"
    - "All data-display patterns have documentation with data structure parameters"
    - "Login form pattern has authentication-focused documentation"
    - "All 5 patterns have Vue and Svelte code examples"
  artifacts:
    - path: ".knowledge/patterns/micro-interactions/button-hover-effect.yaml"
      provides: "Documented button hover with all framework examples"
    - path: ".knowledge/patterns/data-display/data-table.yaml"
      provides: "Documented data table with all framework examples"
    - path: ".knowledge/patterns/authentication/login-form.yaml"
      provides: "Documented login form with all framework examples"
  key_links:
    - from: ".knowledge/patterns/micro-interactions/button-hover-effect.yaml"
      to: ".knowledge/schema/pattern.schema.ts"
      via: "validation"
      pattern: "PatternSchema"
---

<objective>
Add documentation and multi-framework code examples to remaining patterns.

Purpose: Update the final 5 patterns (micro-interactions, data-display, authentication) with comprehensive documentation, framework compatibility metadata, and code examples.
Output: All 14 patterns fully documented with code_examples for all 4 frameworks.
</objective>

<execution_context>
@/Users/khairul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/khairul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-multi-framework-docs/04-RESEARCH.md
@.knowledge/patterns/micro-interactions/button-hover-effect.yaml
@.knowledge/patterns/data-display/data-table.yaml
@.knowledge/patterns/authentication/login-form.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update micro-interactions patterns</name>
  <files>.knowledge/patterns/micro-interactions/button-hover-effect.yaml, .knowledge/patterns/micro-interactions/ripple-effect.yaml</files>
  <action>
For each micro-interactions pattern (button-hover-effect, ripple-effect):

1. Add documentation with animation focus:
```yaml
documentation:
  description: "[Describe the micro-interaction and its UX purpose]"
  usage: "[How to apply this interaction to elements]"
  parameters:
    - name: scale
      type: number
      description: Scale factor on hover (1.0 = no scale)
      required: false
      default: "1.05"
    - name: duration
      type: string
      description: Transition duration (e.g., '200ms')
      required: false
      default: "'200ms'"
  best_practices:
    - "Keep animations subtle (under 300ms for hover)"
    - "Use transform and opacity for GPU-accelerated animations"
    - "Respect prefers-reduced-motion media query"
```

2. Add framework_compatibility:
```yaml
framework_compatibility:
  react: "18.0+"
  vue: "3.0+"
  svelte: "4.0+"
  vanilla: true
```

3. Add Vue code example for hover effect:
```yaml
code_examples:
  vue: |
    <script setup lang="ts">
    interface Props {
      scale?: number;
      duration?: string;
    }
    const props = withDefaults(defineProps<Props>(), {
      scale: 1.05,
      duration: '200ms',
    });
    const style = computed(() => ({
      '--hover-scale': props.scale,
      '--hover-duration': props.duration,
    }));
    </script>
    <template>
      <button class="hover-effect-btn" :style="style">
        <slot />
      </button>
    </template>
    <style scoped>
    .hover-effect-btn {
      transition: transform var(--hover-duration);
    }
    .hover-effect-btn:hover {
      transform: scale(var(--hover-scale));
    }
    @media (prefers-reduced-motion: reduce) {
      .hover-effect-btn { transition: none; }
    }
    </style>
```

4. Add Svelte code example with CSS variables approach.
  </action>
  <verify>
Run pattern validation: `npx tsx .knowledge/schema/validate-patterns.ts`
Both micro-interaction patterns should validate.
  </verify>
  <done>Both micro-interaction patterns have documentation and all framework code examples</done>
</task>

<task type="auto">
  <name>Task 2: Update data-display patterns</name>
  <files>.knowledge/patterns/data-display/data-table.yaml, .knowledge/patterns/data-display/stat-card.yaml</files>
  <action>
For each data-display pattern (data-table, stat-card):

1. Add documentation with data structure focus:
```yaml
documentation:
  description: "[Describe the data display pattern and its use cases]"
  usage: "[How to pass data and render this component]"
  parameters:
    - name: columns
      type: "Column[]"
      description: Column definitions with key, label, sortable
      required: true
    - name: data
      type: "T[]"
      description: Array of data items to display
      required: true
    - name: sortable
      type: boolean
      description: Enable column sorting
      required: false
      default: "false"
  best_practices:
    - "Use semantic table elements for accessibility"
    - "Add row hover states for better scannability"
    - "Consider pagination for large datasets"
```

2. Add framework_compatibility.

3. Add Vue code example for data table:
```yaml
code_examples:
  vue: |
    <script setup lang="ts" generic="T extends Record<string, unknown>">
    interface Column { key: keyof T; label: string; sortable?: boolean; }
    interface Props {
      columns: Column[];
      data: T[];
    }
    defineProps<Props>();
    </script>
    <template>
      <table class="data-table">
        <thead>
          <tr>
            <th v-for="col in columns" :key="String(col.key)">{{ col.label }}</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="(row, idx) in data" :key="idx">
            <td v-for="col in columns" :key="String(col.key)">{{ row[col.key] }}</td>
          </tr>
        </tbody>
      </table>
    </template>
```

4. Add Svelte code examples for both patterns.
  </action>
  <verify>
Run pattern validation: `npx tsx .knowledge/schema/validate-patterns.ts`
Both data-display patterns should validate.
  </verify>
  <done>Both data-display patterns have documentation and all framework code examples</done>
</task>

<task type="auto">
  <name>Task 3: Update authentication pattern</name>
  <files>.knowledge/patterns/authentication/login-form.yaml</files>
  <action>
Update login-form pattern:

1. Add documentation with auth focus:
```yaml
documentation:
  description: "A complete login form with email and password fields, validation states, and submit handling. Designed for authentication flows with proper accessibility and security considerations."
  usage: "Use as a standalone login page component or embed in a modal. Connect onSubmit to your authentication handler."
  parameters:
    - name: onSubmit
      type: "(credentials: { email: string; password: string }) => Promise<void>"
      description: Async handler for form submission
      required: true
    - name: isLoading
      type: boolean
      description: Shows loading state during authentication
      required: false
      default: "false"
    - name: error
      type: string
      description: Error message to display
      required: false
  best_practices:
    - "Never log or expose password values"
    - "Use autocomplete attributes for password managers"
    - "Show clear validation feedback"
    - "Disable submit button while loading"
```

2. Add framework_compatibility:
```yaml
framework_compatibility:
  react: "18.0+"
  vue: "3.0+"
  svelte: "4.0+"
  vanilla: true
```

3. Add Vue code example:
```yaml
code_examples:
  vue: |
    <script setup lang="ts">
    import { ref } from 'vue';
    interface Props {
      isLoading?: boolean;
      error?: string;
    }
    const props = withDefaults(defineProps<Props>(), { isLoading: false });
    const emit = defineEmits<{
      submit: [{ email: string; password: string }];
    }>();
    const email = ref('');
    const password = ref('');
    const handleSubmit = () => {
      emit('submit', { email: email.value, password: password.value });
    };
    </script>
    <template>
      <form @submit.prevent="handleSubmit" class="login-form">
        <div v-if="error" class="error">{{ error }}</div>
        <input v-model="email" type="email" placeholder="Email" autocomplete="email" required />
        <input v-model="password" type="password" placeholder="Password" autocomplete="current-password" required />
        <button type="submit" :disabled="isLoading">
          {{ isLoading ? 'Signing in...' : 'Sign In' }}
        </button>
      </form>
    </template>
```

4. Add Svelte code example with form handling.
  </action>
  <verify>
Run pattern validation: `npx tsx .knowledge/schema/validate-patterns.ts`
Login form pattern should validate.
  </verify>
  <done>Login form pattern has documentation and all framework code examples</done>
</task>

</tasks>

<verification>
- [ ] All 5 patterns have documentation field
- [ ] All 5 patterns have framework_compatibility field
- [ ] All 5 patterns have code_examples for all 4 frameworks
- [ ] Pattern validation passes for all 14 patterns total
</verification>

<success_criteria>
Remaining patterns (5 total) updated with:
- Full documentation (description, usage, parameters, best_practices)
- Framework compatibility metadata
- Code examples for Vue and Svelte
All 14 patterns in the knowledge base are now fully documented.
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-framework-docs/04-05-SUMMARY.md`
</output>

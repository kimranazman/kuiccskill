---
phase: 05-integration-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .knowledge/lib/cache.ts
  - .knowledge/lib/index.ts
autonomous: true

must_haves:
  truths:
    - "Pattern search returns results in under 100ms"
    - "Search index rebuilds automatically when patterns change"
    - "Existing searchPatterns API continues to work unchanged"
  artifacts:
    - path: ".knowledge/lib/cache.ts"
      provides: "In-memory pattern index with fast lookup"
      exports: ["buildIndex", "getIndex", "searchFast", "invalidateCache"]
  key_links:
    - from: ".knowledge/lib/cache.ts"
      to: ".knowledge/lib/storage.ts"
      via: "imports listPatterns, loadPattern"
      pattern: "import.*from.*storage"
---

<objective>
Implement in-memory pattern caching and fast search for sub-100ms lookups.

Purpose: Current search reads all YAML files on every query. With 14+ patterns this is fine, but the requirement (INT-05) specifies <100ms p95 latency. Pre-building an index on first access ensures consistent fast performance.

Output: A new cache module with indexed search that can be used as a drop-in replacement for current search, plus automatic cache invalidation.
</objective>

<execution_context>
@/Users/khairul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/khairul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-integration-performance/05-RESEARCH.md
@.knowledge/lib/search.ts
@.knowledge/lib/storage.ts
@.knowledge/lib/index.ts
@.knowledge/schema/categories.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pattern cache module</name>
  <files>.knowledge/lib/cache.ts</files>
  <action>
Create a new cache module that implements:

1. **PatternIndex interface:**
```typescript
interface PatternMetadata {
  file: string;
  name: string;
  category: Category;
  tags: string[];
  frameworks: Framework[];
}

interface PatternIndex {
  byId: Map<string, PatternMetadata>;
  byTag: Map<string, Set<string>>;       // lowercase tag -> pattern IDs
  byCategory: Map<Category, Set<string>>;
  byFramework: Map<Framework, Set<string>>;
  buildTime: number;  // ms to build
}
```

2. **buildIndex()** - Builds the full index from disk:
   - Call listPatterns() to get all YAML files
   - Load each pattern, extract metadata
   - Populate all index Maps
   - Track build time for diagnostics
   - Return the populated index

3. **getIndex()** - Lazy singleton access:
   - Return cached index if exists
   - Build index on first access
   - Handle concurrent build requests (only one build at a time)

4. **searchFast(options: SearchOptions)** - O(1) indexed search:
   - Get index via getIndex()
   - For tags: intersect byTag sets
   - For category: get byCategory set
   - For framework: get byFramework set
   - Intersect all applicable sets
   - Return pattern IDs (not full patterns - caller loads if needed)

5. **invalidateCache()** - Clear cached index:
   - Set index to null
   - Next getIndex() call will rebuild

Use ES6 Set operations for intersection. Do NOT add external dependencies (lru-cache, etc.) - simple Map/Set is sufficient for 14-100 patterns.
  </action>
  <verify>
```bash
# TypeScript compiles
npx tsc --noEmit .knowledge/lib/cache.ts

# Module exports expected functions
grep -E "export (async )?function (buildIndex|getIndex|searchFast|invalidateCache)" .knowledge/lib/cache.ts
```
  </verify>
  <done>cache.ts exists with buildIndex, getIndex, searchFast, invalidateCache functions exported</done>
</task>

<task type="auto">
  <name>Task 2: Add cache exports to lib barrel</name>
  <files>.knowledge/lib/index.ts</files>
  <action>
Add exports for the new cache module to the existing barrel file:

```typescript
// Re-export cache operations (fast indexed search)
export {
  buildIndex,
  getIndex,
  searchFast,
  invalidateCache,
} from './cache';
```

Preserve all existing exports. The cache module provides an optional faster search path; existing searchPatterns continues to work for backward compatibility.
  </action>
  <verify>
```bash
# Check exports exist
grep -E "searchFast|buildIndex|getIndex|invalidateCache" .knowledge/lib/index.ts
```
  </verify>
  <done>index.ts barrel exports all cache functions alongside existing storage/search exports</done>
</task>

<task type="auto">
  <name>Task 3: Add performance benchmark script</name>
  <files>.knowledge/lib/benchmark.ts</files>
  <action>
Create a simple benchmark script that compares old vs new search:

```typescript
import { searchPatterns } from './search';
import { searchFast, getIndex, invalidateCache } from './cache';
import { loadPattern } from './storage';

async function benchmark() {
  console.log('Pattern Search Benchmark\n');

  // Warm up / build index
  invalidateCache();
  const indexStart = performance.now();
  const index = await getIndex();
  const indexTime = performance.now() - indexStart;
  console.log(`Index build: ${indexTime.toFixed(2)}ms (${index.byId.size} patterns)`);

  // Test searches
  const tests = [
    { tags: ['grid'], category: undefined },
    { tags: ['hover', 'animation'], category: undefined },
    { category: 'forms' as const },
    { framework: 'react' as const },
  ];

  for (const opts of tests) {
    // Old search
    const oldStart = performance.now();
    const oldResults = await searchPatterns(opts);
    const oldTime = performance.now() - oldStart;

    // New search
    const newStart = performance.now();
    const newIds = await searchFast(opts);
    const newTime = performance.now() - newStart;

    console.log(`\nSearch ${JSON.stringify(opts)}:`);
    console.log(`  Old: ${oldTime.toFixed(2)}ms (${oldResults.length} results)`);
    console.log(`  New: ${newTime.toFixed(2)}ms (${newIds.length} IDs)`);
    console.log(`  Speedup: ${(oldTime / newTime).toFixed(1)}x`);
  }
}

benchmark().catch(console.error);
```

This is a utility script for verification, not production code.
  </action>
  <verify>
```bash
# Run benchmark
npx tsx .knowledge/lib/benchmark.ts
```
  </verify>
  <done>Benchmark script runs and shows searchFast is faster than searchPatterns</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors:
   ```bash
   npx tsc --noEmit .knowledge/lib/cache.ts .knowledge/lib/benchmark.ts
   ```

2. Benchmark shows performance improvement:
   ```bash
   npx tsx .knowledge/lib/benchmark.ts 2>&1 | grep -E "New:.*ms"
   ```
   All "New" times should be < 10ms (well under 100ms target)

3. Index includes all patterns:
   ```bash
   npx tsx -e "import { getIndex } from './.knowledge/lib/cache'; getIndex().then(i => console.log('Patterns indexed:', i.byId.size))"
   ```
   Should show 14 (current pattern count)
</verification>

<success_criteria>
- [ ] cache.ts implements in-memory pattern index with Map/Set data structures
- [ ] searchFast returns pattern IDs matching search criteria in <10ms
- [ ] Index builds lazily on first access
- [ ] invalidateCache allows manual cache clearing
- [ ] Benchmark shows measurable speedup over file-based search
- [ ] All exports properly re-exported from index.ts barrel
</success_criteria>

<output>
After completion, create `.planning/phases/05-integration-performance/05-01-SUMMARY.md`
</output>

---
phase: 05-integration-performance
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - .knowledge/integration/context-analyzer.ts
  - .knowledge/integration/suggestion-engine.ts
  - .knowledge/integration/index.ts
autonomous: true

must_haves:
  truths:
    - "Context analyzer extracts relevant categories from text input"
    - "Suggestion engine returns ranked patterns with relevance scores"
    - "Suggestions include reasoning for why pattern matches"
  artifacts:
    - path: ".knowledge/integration/context-analyzer.ts"
      provides: "Keyword-to-category mapping and text analysis"
      exports: ["extractCategories", "analyzeTaskContext", "CATEGORY_KEYWORDS"]
    - path: ".knowledge/integration/suggestion-engine.ts"
      provides: "Pattern suggestion with ranking"
      exports: ["suggestPatterns", "PatternSuggestion"]
  key_links:
    - from: ".knowledge/integration/suggestion-engine.ts"
      to: ".knowledge/lib/cache.ts"
      via: "imports searchFast for fast pattern lookup"
      pattern: "import.*searchFast.*cache"
    - from: ".knowledge/integration/suggestion-engine.ts"
      to: ".knowledge/integration/context-analyzer.ts"
      via: "imports extractCategories"
      pattern: "import.*extractCategories"
---

<objective>
Implement context-aware pattern suggestion engine.

Purpose: Requirement INT-04 specifies context-aware suggestions that recommend patterns based on current task. When a user is building a form, suggest form patterns; when building navigation, suggest navigation patterns.

Output: A context analyzer that extracts relevant categories from task description, and a suggestion engine that ranks and returns matching patterns with explanations.
</objective>

<execution_context>
@/Users/khairul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/khairul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-integration-performance/05-RESEARCH.md
@.knowledge/lib/cache.ts
@.knowledge/schema/categories.ts
@.knowledge/integration/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create context analyzer</name>
  <files>.knowledge/integration/context-analyzer.ts</files>
  <action>
Create a module that analyzes task context and extracts relevant pattern categories:

```typescript
import type { Category, Framework } from '../schema/categories';

/**
 * Keyword-to-category mapping.
 * Each keyword maps to one or more relevant categories.
 */
export const CATEGORY_KEYWORDS: Record<string, Category[]> = {
  // Forms
  'form': ['forms'],
  'input': ['forms'],
  'select': ['forms'],
  'checkbox': ['forms'],
  'radio': ['forms'],
  'textarea': ['forms'],
  'validation': ['forms'],
  'submit': ['forms'],
  'field': ['forms'],

  // Navigation
  'nav': ['navigation'],
  'navbar': ['navigation'],
  'menu': ['navigation'],
  'breadcrumb': ['navigation'],
  'sidebar': ['navigation'],
  'header': ['navigation'],
  'footer': ['navigation'],
  'tabs': ['navigation'],
  'link': ['navigation'],

  // Layout
  'grid': ['layout'],
  'flex': ['layout'],
  'container': ['layout'],
  'section': ['layout'],
  'hero': ['layout'],
  'column': ['layout'],
  'row': ['layout'],
  'responsive': ['layout'],
  'layout': ['layout'],

  // Data Display
  'table': ['data-display'],
  'list': ['data-display'],
  'card': ['data-display', 'layout'],  // Cards span both
  'stat': ['data-display'],
  'chart': ['data-display'],
  'badge': ['data-display'],
  'avatar': ['data-display'],

  // Feedback
  'loading': ['feedback'],
  'spinner': ['feedback'],
  'skeleton': ['feedback'],
  'toast': ['feedback'],
  'alert': ['feedback'],
  'notification': ['feedback'],
  'progress': ['feedback'],
  'error': ['feedback'],
  'success': ['feedback'],

  // Micro-interactions
  'hover': ['micro-interactions'],
  'transition': ['micro-interactions'],
  'animation': ['micro-interactions'],
  'click': ['micro-interactions'],
  'ripple': ['micro-interactions'],
  'effect': ['micro-interactions'],

  // Authentication
  'login': ['authentication'],
  'signup': ['authentication'],
  'register': ['authentication'],
  'password': ['authentication'],
  'auth': ['authentication'],
  'signin': ['authentication'],
};

export interface TaskContext {
  text: string;
  categories: Category[];
  keywords: string[];
  framework?: Framework;
}

/**
 * Extract relevant categories from text.
 */
export function extractCategories(text: string): Category[] {
  const words = text.toLowerCase().split(/\W+/).filter(w => w.length > 2);
  const categories = new Set<Category>();

  for (const word of words) {
    const matches = CATEGORY_KEYWORDS[word];
    if (matches) {
      matches.forEach(c => categories.add(c));
    }
  }

  return Array.from(categories);
}

/**
 * Analyze task context from text description.
 */
export function analyzeTaskContext(text: string, framework?: Framework): TaskContext {
  const categories = extractCategories(text);
  const words = text.toLowerCase().split(/\W+/).filter(w => w.length > 2);
  const keywords = words.filter(w => CATEGORY_KEYWORDS[w]);

  return {
    text,
    categories,
    keywords,
    framework,
  };
}
```
  </action>
  <verify>
```bash
# File exists
ls -la .knowledge/integration/context-analyzer.ts

# Test extraction
npx tsx -e "
import { extractCategories } from './.knowledge/integration/context-analyzer';
console.log('Building a login form:', extractCategories('building a login form'));
console.log('Hero section with grid:', extractCategories('hero section with grid layout'));
console.log('Loading spinner:', extractCategories('need a loading spinner'));
"
```
  </verify>
  <done>context-analyzer.ts extracts categories from text with keyword mapping</done>
</task>

<task type="auto">
  <name>Task 2: Create suggestion engine</name>
  <files>.knowledge/integration/suggestion-engine.ts</files>
  <action>
Create a module that generates pattern suggestions based on context:

```typescript
import type { Pattern } from '../schema/pattern.schema';
import type { Category, Framework } from '../schema/categories';
import { searchFast, getIndex } from '../lib/cache';
import { loadPattern } from '../lib/storage';
import { extractCategories, analyzeTaskContext, type TaskContext } from './context-analyzer';

export interface PatternSuggestion {
  pattern: Pattern;
  relevance: number;  // 0-1 score
  reason: string;     // Human-readable explanation
  matchedKeywords: string[];
}

export interface SuggestOptions {
  text?: string;           // Task description to analyze
  categories?: Category[]; // Direct category filter (overrides text)
  framework?: Framework;   // Filter by framework
  limit?: number;          // Max suggestions (default: 5)
  minRelevance?: number;   // Minimum relevance threshold (default: 0.3)
}

/**
 * Calculate relevance score for a pattern given the context.
 */
function calculateRelevance(
  pattern: Pattern,
  context: TaskContext
): { score: number; matchedKeywords: string[] } {
  let score = 0;
  const matchedKeywords: string[] = [];

  // Category match: major boost
  if (context.categories.includes(pattern.category)) {
    score += 0.5;
  }

  // Tag overlap with keywords: incremental boost
  for (const tag of pattern.tags) {
    if (context.keywords.includes(tag.toLowerCase())) {
      score += 0.15;
      matchedKeywords.push(tag);
    }
  }

  // Framework match: minor boost if specified
  if (context.framework && pattern.frameworks.includes(context.framework)) {
    score += 0.1;
  }

  return { score: Math.min(score, 1), matchedKeywords };
}

/**
 * Generate human-readable reason for suggestion.
 */
function generateReason(
  pattern: Pattern,
  context: TaskContext,
  matchedKeywords: string[]
): string {
  const parts: string[] = [];

  if (context.categories.includes(pattern.category)) {
    parts.push(`matches ${pattern.category} category`);
  }

  if (matchedKeywords.length > 0) {
    parts.push(`tags match: ${matchedKeywords.join(', ')}`);
  }

  if (context.framework && pattern.frameworks.includes(context.framework)) {
    parts.push(`supports ${context.framework}`);
  }

  return parts.length > 0 ? parts.join('; ') : 'general match';
}

/**
 * Get pattern suggestions based on context.
 */
export async function suggestPatterns(options: SuggestOptions): Promise<PatternSuggestion[]> {
  const limit = options.limit ?? 5;
  const minRelevance = options.minRelevance ?? 0.3;

  // Build context
  const context = options.text
    ? analyzeTaskContext(options.text, options.framework)
    : {
        text: '',
        categories: options.categories ?? [],
        keywords: [],
        framework: options.framework,
      };

  // If no categories detected, return empty
  if (context.categories.length === 0 && !options.categories) {
    return [];
  }

  // Get candidate patterns using fast search
  const index = await getIndex();
  const candidateIds = new Set<string>();

  // Collect candidates from all matching categories
  const categoriesToSearch = options.categories ?? context.categories;
  for (const category of categoriesToSearch) {
    const categoryPatterns = index.byCategory.get(category);
    if (categoryPatterns) {
      categoryPatterns.forEach(id => candidateIds.add(id));
    }
  }

  // Load patterns and calculate relevance
  const suggestions: PatternSuggestion[] = [];

  for (const id of candidateIds) {
    const meta = index.byId.get(id);
    if (!meta) continue;

    // Framework filter
    if (context.framework && !meta.frameworks.includes(context.framework)) {
      continue;
    }

    const pattern = await loadPattern(meta.file);
    const { score, matchedKeywords } = calculateRelevance(pattern, context);

    if (score >= minRelevance) {
      suggestions.push({
        pattern,
        relevance: score,
        reason: generateReason(pattern, context, matchedKeywords),
        matchedKeywords,
      });
    }
  }

  // Sort by relevance and limit
  suggestions.sort((a, b) => b.relevance - a.relevance);
  return suggestions.slice(0, limit);
}
```
  </action>
  <verify>
```bash
# File exists
ls -la .knowledge/integration/suggestion-engine.ts

# Test suggestions
npx tsx -e "
import { suggestPatterns } from './.knowledge/integration/suggestion-engine';
suggestPatterns({ text: 'I need to build a login form with validation' }).then(suggestions => {
  console.log('Suggestions for login form:');
  for (const s of suggestions) {
    console.log(\`  [\${(s.relevance * 100).toFixed(0)}%] \${s.pattern.name}: \${s.reason}\`);
  }
});
"
```
  </verify>
  <done>suggestion-engine.ts generates ranked pattern suggestions with relevance scores</done>
</task>

<task type="auto">
  <name>Task 3: Update integration barrel exports</name>
  <files>.knowledge/integration/index.ts</files>
  <action>
Update the integration module barrel to export context analyzer and suggestion engine:

```typescript
/**
 * Integration module for KUI Design skill.
 * Contains quality gates, context analysis, and workflow integration.
 */

// Re-export quality gate types and functions
export {
  validateQuality,
  type QualityResult,
  type QualityIssue,
  type Severity,
} from './quality-gates';

// Re-export context analysis
export {
  extractCategories,
  analyzeTaskContext,
  CATEGORY_KEYWORDS,
  type TaskContext,
} from './context-analyzer';

// Re-export suggestion engine
export {
  suggestPatterns,
  type PatternSuggestion,
  type SuggestOptions,
} from './suggestion-engine';
```
  </action>
  <verify>
```bash
# Check all exports
grep -E "export.*from" .knowledge/integration/index.ts

# Verify imports work
npx tsx -e "import { suggestPatterns, extractCategories, validateQuality } from './.knowledge/integration'; console.log('All imports work');"
```
  </verify>
  <done>integration/index.ts exports all context analysis and suggestion functions</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors:
   ```bash
   npx tsc --noEmit .knowledge/integration/*.ts
   ```

2. Context extraction works correctly:
   ```bash
   npx tsx -e "
   import { extractCategories } from './.knowledge/integration';
   console.log('Form keywords:', extractCategories('input validation form submit'));
   console.log('Nav keywords:', extractCategories('navbar menu sidebar'));
   "
   ```
   Should return forms-related and navigation-related categories

3. Suggestions include relevance and reasoning:
   ```bash
   npx tsx -e "
   import { suggestPatterns } from './.knowledge/integration';
   suggestPatterns({ text: 'building a card grid layout' }).then(s => {
     console.log(JSON.stringify(s.map(x => ({ name: x.pattern.name, relevance: x.relevance, reason: x.reason })), null, 2));
   });
   "
   ```
</verification>

<success_criteria>
- [ ] context-analyzer.ts maps keywords to pattern categories
- [ ] extractCategories returns relevant categories for task descriptions
- [ ] suggestion-engine.ts calculates relevance scores based on context
- [ ] suggestPatterns returns ranked suggestions with human-readable reasons
- [ ] Suggestions limited by relevance threshold (default 0.3)
- [ ] All exports available through integration barrel
</success_criteria>

<output>
After completion, create `.planning/phases/05-integration-performance/05-03-SUMMARY.md`
</output>
